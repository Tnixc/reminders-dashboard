package main

import (
	"fmt"
	"strings"

	"github.com/charmbracelet/lipgloss"
)

// min returns the minimum of two integers
func min(a, b int) int {
	if a < b {
		return a
	}
	return b
}

// getContentHeight returns the available height for content (excluding footer)
func (m *model) getContentHeight() int {
	// Account for footer (1 line)
	return m.height - 1
}

// View renders the UI
func (m model) View() string {
	// Define base styles
	footerStyle := lipgloss.NewStyle().
		Foreground(lipgloss.Color("241")).
		Background(lipgloss.Color("235")).
		Padding(0, 1).
		Width(m.width)

	// Render footer
	helpText := "tab: view ‚Ä¢ s: focus sidebar ‚Ä¢ r: refresh ‚Ä¢ ‚Üë/‚Üì: items ‚Ä¢ q: quit"
	if m.sidebarFocused {
		if m.sidebarSection == SidebarColorConfig {
			helpText = "tab: section ‚Ä¢ 1-9/0: pick color ‚Ä¢ ‚Üë/‚Üì: lists ‚Ä¢ s: unfocus sidebar ‚Ä¢ q: quit"
		} else {
			helpText = "tab: section ‚Ä¢ space: toggle ‚Ä¢ ‚Üë/‚Üì: navigate ‚Ä¢ s: unfocus sidebar ‚Ä¢ q: quit"
		}
	} else if m.viewMode == ColumnView {
		helpText = "tab: view ‚Ä¢ s: focus sidebar ‚Ä¢ ctrl+‚Üê/‚Üí: reorder ‚Ä¢ ‚Üê/‚Üí: columns ‚Ä¢ ‚Üë/‚Üì: items ‚Ä¢ q: quit"
	}
	footer := footerStyle.Render(helpText)

	// Handle special states
	var content string
	if m.loading {
		content = renderLoading(m.width, m.height-1)
	} else if m.err != nil {
		content = renderError(m.err, m.width, m.height-1)
	} else {
		// Render main content and sidebar with responsive widths
		var mainContent string
		if m.viewMode == ColumnView {
			mainContent = m.renderColumnView()
		} else {
			mainContent = m.renderListView()
		}

		// Responsive sidebar width with clamping so total <= m.width
		minMain := 20
		desiredSidebar := m.width / 3
		if desiredSidebar < 24 {
			desiredSidebar = 24
		}
		if desiredSidebar > 48 {
			desiredSidebar = 48
		}

		// Ensure main + sidebar fits; shrink sidebar if necessary
		sidebarWidth := desiredSidebar
		if m.width-sidebarWidth < minMain {
			sidebarWidth = m.width - minMain
			if sidebarWidth < 0 {
				sidebarWidth = 0
			}
		}
		mainWidth := m.width - sidebarWidth
		contentHeight := m.getContentHeight()

		sidebar := m.renderSidebar(sidebarWidth)

		mainStyle := lipgloss.NewStyle().Width(mainWidth).Height(contentHeight)
		sidebarStyle := lipgloss.NewStyle().Width(sidebarWidth).Height(contentHeight)

		content = lipgloss.JoinHorizontal(lipgloss.Top,
			mainStyle.Render(mainContent),
			sidebarStyle.Render(sidebar))
	}

	// Combine all parts
	return lipgloss.JoinVertical(lipgloss.Left, content, footer)
}

func renderLoading(width, height int) string {
	style := lipgloss.NewStyle().
		Width(width).
		Height(height).
		Align(lipgloss.Center).
		AlignVertical(lipgloss.Center)

	return style.Render("Loading reminders...")
}

func renderError(err error, width, height int) string {
	style := lipgloss.NewStyle().
		Width(width).
		Height(height).
		Align(lipgloss.Center).
		AlignVertical(lipgloss.Center).
		Foreground(lipgloss.Color("196"))

	return style.Render(fmt.Sprintf("Error loading reminders:\n%v\n\nPress q to quit", err))
}

func (m model) renderSidebar(width int) string {
	contentHeight := m.getContentHeight()

	// Minimum heights for each section
	minDaysHeight := 5
	minListHeight := 7
	minColorHeight := 7
	totalMinHeight := minDaysHeight + minListHeight + minColorHeight

	var daysHeight, listHeight, colorHeight int

	if contentHeight >= totalMinHeight {
		// Allocate height proportionally
		// Days Filter: ~20% of height
		// List Filter: ~45% of height
		// Color Config: ~35% of height
		daysHeight = contentHeight * 20 / 100
		listHeight = contentHeight * 45 / 100
		colorHeight = contentHeight - daysHeight - listHeight // remainder

		// Ensure minimum heights
		if daysHeight < minDaysHeight {
			daysHeight = minDaysHeight
		}
		if listHeight < minListHeight {
			listHeight = minListHeight
		}
		if colorHeight < minColorHeight {
			colorHeight = minColorHeight
		}

		// If total exceeds contentHeight, reduce proportionally
		totalAllocated := daysHeight + listHeight + colorHeight
		if totalAllocated > contentHeight {
			excess := totalAllocated - contentHeight
			// Reduce from color section first, then list, then days
			if colorHeight > minColorHeight {
				reduce := min(excess, colorHeight - minColorHeight)
				colorHeight -= reduce
				excess -= reduce
			}
			if excess > 0 && listHeight > minListHeight {
				reduce := min(excess, listHeight - minListHeight)
				listHeight -= reduce
				excess -= reduce
			}
			if excess > 0 && daysHeight > minDaysHeight {
				reduce := min(excess, daysHeight - minDaysHeight)
				daysHeight -= reduce
			}
		}
	} else {
		// Terminal too short, use minimum heights proportionally
		daysHeight = contentHeight * minDaysHeight / totalMinHeight
		listHeight = contentHeight * minListHeight / totalMinHeight
		colorHeight = contentHeight - daysHeight - listHeight
		if daysHeight < 3 {
			daysHeight = 3
		}
		if listHeight < 4 {
			listHeight = 4
		}
		if colorHeight < 4 {
			colorHeight = 4
		}
	}

	var sections []string

	// Days Filter Section
	sections = append(sections, m.renderDaysFilterSection(daysHeight, width))

	// List Filter Section
	sections = append(sections, m.renderListFilterSection(listHeight, width))

	// Color Config Section
	sections = append(sections, m.renderColorConfigSection(colorHeight, width))

	return lipgloss.JoinVertical(lipgloss.Left, sections...)
}

func (m model) renderDaysFilterSection(height int, width int) string {
	var content strings.Builder

	innerWidth := width - 2 // account for left and right padding

	// Section title
	titleStyle := lipgloss.NewStyle().
		Bold(true).
		Foreground(lipgloss.Color("248"))
	
	if m.sidebarFocused && m.sidebarSection == SidebarDaysFilter {
		titleStyle = titleStyle.Foreground(lipgloss.Color("205"))
	}
	
	titleStyle = titleStyle.Width(innerWidth)
	content.WriteString(titleStyle.Render("üìÖ Days Filter") + "\n\n")

	// Section content
	if m.sidebarFocused && m.sidebarSection == SidebarDaysFilter {
		// Compute visible rows based on available height (minus borders and title)
		innerHeight := height - 2 // top+bottom border
		overhead := 2             // title + blank line
		visibleRows := innerHeight - overhead
		if visibleRows < 1 {
			visibleRows = 1
		}

		startIdx := 0
		endIdx := len(m.daysFilterOptions)

		// Scroll if needed
		if len(m.daysFilterOptions) > visibleRows {
			if m.sidebarCursor >= visibleRows {
				startIdx = m.sidebarCursor - visibleRows + 1
			}
			endIdx = startIdx + visibleRows
			if endIdx > len(m.daysFilterOptions) {
				endIdx = len(m.daysFilterOptions)
			}
		}

		for i := startIdx; i < endIdx; i++ {
			days := m.daysFilterOptions[i]
			cursor := " "
			if m.sidebarCursor == i {
				cursor = "‚ñ∏"
			}

			checked := "‚óã"
			label := "All reminders"
			if days > 0 {
				label = fmt.Sprintf("Next %d days", days)
			}

			if m.daysFilter == days {
				checked = "‚óè"
			}

			style := lipgloss.NewStyle()
			if m.sidebarCursor == i {
				style = style.Bold(true).Foreground(lipgloss.Color("205"))
			}

			line := fmt.Sprintf("%s %s %s", cursor, checked, label)
			content.WriteString(style.Width(innerWidth).Render(line) + "\n")
		}
	} else {
		// Show current selection when not focused
		dimStyle := lipgloss.NewStyle().Foreground(lipgloss.Color("243"))
		if m.daysFilter == 0 {
			content.WriteString(dimStyle.Width(innerWidth).Render(" ‚óè All reminders\n"))
		} else {
			content.WriteString(dimStyle.Width(innerWidth).Render(fmt.Sprintf(" ‚óè Next %d days\n", m.daysFilter)))
		}
	}

	// Wrap in border with fixed height and width
	borderStyle := lipgloss.NewStyle().
		BorderStyle(lipgloss.RoundedBorder()).
		BorderForeground(lipgloss.Color("240")).
		Padding(0, 1).
		Width(width).
		Height(height)

	if m.sidebarFocused && m.sidebarSection == SidebarDaysFilter {
		borderStyle = borderStyle.BorderForeground(lipgloss.Color("205"))
	}

	return borderStyle.Render(content.String())
}

func (m model) renderListFilterSection(height int, width int) string {
	var content strings.Builder

	innerWidth := width - 2 // account for left and right padding

	// Section title
	titleStyle := lipgloss.NewStyle().
		Bold(true).
		Foreground(lipgloss.Color("248"))
	
	if m.sidebarFocused && m.sidebarSection == SidebarListFilter {
		titleStyle = titleStyle.Foreground(lipgloss.Color("205"))
	}
	
	titleStyle = titleStyle.Width(innerWidth)
	content.WriteString(titleStyle.Render("üìã List Filter") + "\n\n")

	dimStyle := lipgloss.NewStyle().Foreground(lipgloss.Color("243")).Width(innerWidth)

	if m.sidebarFocused && m.sidebarSection == SidebarListFilter {
		// Compute visible rows based on section height (minus borders and title)
		innerHeight := height - 2 // top+bottom border
		overhead := 2             // title + blank line
		visibleRows := innerHeight - overhead
		if visibleRows < 1 {
			visibleRows = 1
		}

		startIdx := 0
		endIdx := len(m.availableLists)

		// Scroll if needed
		if len(m.availableLists) > visibleRows {
			if m.sidebarCursor >= visibleRows {
				startIdx = m.sidebarCursor - visibleRows + 1
			}
			endIdx = startIdx + visibleRows
			if endIdx > len(m.availableLists) {
				endIdx = len(m.availableLists)
			}
		}

		for i := startIdx; i < endIdx; i++ {
			listName := m.availableLists[i]
			cursor := " "
			if m.sidebarCursor == i {
				cursor = "‚ñ∏"
			}

			checked := "‚òê"
			if m.selectedLists[listName] {
				checked = "‚òë"
			}

			style := lipgloss.NewStyle()
			if m.sidebarCursor == i {
				style = style.Bold(true).Foreground(lipgloss.Color("205"))
			}

			// Show list color indicator
			color := m.listColors[listName]
			colorIndicator := lipgloss.NewStyle().Foreground(lipgloss.Color(color)).Render("‚óè")

			line := fmt.Sprintf("%s %s %s %s", cursor, checked, colorIndicator, listName)
			content.WriteString(style.Width(innerWidth).Render(line) + "\n")
		}
	} else {
		// Show count of selected lists when not focused
		selectedCount := 0
		for _, selected := range m.selectedLists {
			if selected {
				selectedCount++
			}
		}
		content.WriteString(dimStyle.Render(fmt.Sprintf(" %d/%d lists selected\n", selectedCount, len(m.availableLists))))
	}

	// Wrap in border with fixed height and width
	borderStyle := lipgloss.NewStyle().
		BorderStyle(lipgloss.RoundedBorder()).
		BorderForeground(lipgloss.Color("240")).
		Padding(0, 1).
		Width(width).
		Height(height)

	if m.sidebarFocused && m.sidebarSection == SidebarListFilter {
		borderStyle = borderStyle.BorderForeground(lipgloss.Color("205"))
	}

	return borderStyle.Render(content.String())
}

func (m model) renderColorConfigSection(height int, width int) string {
	var content strings.Builder

	innerWidth := width - 2 // account for left and right padding

	// Section title
	titleStyle := lipgloss.NewStyle().
		Bold(true).
		Foreground(lipgloss.Color("248"))

	if m.sidebarFocused && m.sidebarSection == SidebarColorConfig {
		titleStyle = titleStyle.Foreground(lipgloss.Color("205"))
	}

	titleStyle = titleStyle.Width(innerWidth)
	content.WriteString(titleStyle.Render("üé® List Colors") + "\n\n")

	dimStyle := lipgloss.NewStyle().Foreground(lipgloss.Color("243")).Width(innerWidth)

	if m.sidebarFocused && m.sidebarSection == SidebarColorConfig {
		innerHeight := height - 2 // top+bottom border
		titleOverhead := 2        // title + blank line
		availableHeight := innerHeight - titleOverhead

		// Split available height: top half for list selection, bottom half for color picking
		listAreaHeight := availableHeight / 2
		paletteAreaHeight := availableHeight - listAreaHeight

		// Render list selection area
		var listLines []string
		visibleLists := listAreaHeight
		if visibleLists > len(m.availableLists) {
			visibleLists = len(m.availableLists)
		}

		startIdx := 0
		if len(m.availableLists) > visibleLists {
			if m.sidebarCursor >= visibleLists {
				startIdx = m.sidebarCursor - visibleLists + 1
			}
		}
		endIdx := startIdx + visibleLists
		if endIdx > len(m.availableLists) {
			endIdx = len(m.availableLists)
		}

		for i := startIdx; i < endIdx; i++ {
			listName := m.availableLists[i]
			cursor := " "
			if m.sidebarCursor == i {
				cursor = "‚ñ∏"
			}

			color := m.listColors[listName]
			colorIndicator := lipgloss.NewStyle().Foreground(lipgloss.Color(color)).Bold(true).Render("‚óè")

			style := lipgloss.NewStyle()
			if m.sidebarCursor == i {
				style = style.Bold(true).Foreground(lipgloss.Color("205"))
			}

			line := fmt.Sprintf("%s %s %s", cursor, colorIndicator, listName)
			listLines = append(listLines, style.Width(innerWidth).Render(line))
		}

		// Pad list area to fill height
		for len(listLines) < listAreaHeight {
			listLines = append(listLines, lipgloss.NewStyle().Width(innerWidth).Render(""))
		}

		// Render palette area
		var paletteLines []string
		if m.sidebarCursor < len(m.availableLists) {
			paletteLines = append(paletteLines, dimStyle.Render("Pick a color:"))

			listName := m.availableLists[m.sidebarCursor]
			currentColor := m.listColors[listName]

			paletteRows := paletteAreaHeight - 1 // minus the "Pick a color:" line
			if paletteRows < 0 {
				paletteRows = 0
			}
			if paletteRows > len(m.availableColors) {
				paletteRows = len(m.availableColors)
			}

			for i := 0; i < paletteRows; i++ {
				color := m.availableColors[i]
				colorName := m.colorNames[i]
				colorStyle := lipgloss.NewStyle().Foreground(lipgloss.Color(color)).Bold(true)

				keyNum := (i + 1) % 10 // 1-9, then 0 for 10th

				indicator := " "
				if color == currentColor {
					indicator = "‚ñ∏"
				}

				preview := colorStyle.Render("‚ñà‚ñà")
				line := fmt.Sprintf("%s %d %s %s", indicator, keyNum, preview, colorName)

				if color == currentColor {
					line = lipgloss.NewStyle().Bold(true).Foreground(lipgloss.Color("205")).Width(innerWidth).Render(line)
				} else {
					line = lipgloss.NewStyle().Width(innerWidth).Render(line)
				}

				paletteLines = append(paletteLines, line)
			}

			if paletteRows < len(m.availableColors) {
				paletteLines = append(paletteLines, dimStyle.Render(" ...more"))
			}
		}

		// Pad palette area to fill height
		for len(paletteLines) < paletteAreaHeight {
			paletteLines = append(paletteLines, lipgloss.NewStyle().Width(innerWidth).Render(""))
		}

		// Combine list and palette areas
		allLines := append(listLines, paletteLines...)
		for _, line := range allLines {
			content.WriteString(line + "\n")
		}
	} else {
		// Show instruction when not focused
		content.WriteString(dimStyle.Render(" Press 's' to configure\n"))
		// Pad to fill height
		innerHeight := height - 2
		currentLines := 3 // title 2 + instruction 1
		for currentLines < innerHeight {
			content.WriteString(lipgloss.NewStyle().Width(innerWidth).Render("") + "\n")
			currentLines++
		}
	}

	// Wrap in border with fixed height and width
	borderStyle := lipgloss.NewStyle().
		BorderStyle(lipgloss.RoundedBorder()).
		BorderForeground(lipgloss.Color("240")).
		Padding(0, 1).
		Width(width).
		Height(height)

	if m.sidebarFocused && m.sidebarSection == SidebarColorConfig {
		borderStyle = borderStyle.BorderForeground(lipgloss.Color("205"))
	}

	return borderStyle.Render(content.String())
}

func (m model) renderListView() string {
	contentHeight := m.height - 1 // minus footer
	var lines []string

	filtered := getFilteredReminders(&m)

	if len(filtered) == 0 {
		content := "  No reminders to display"
		// Pad with empty lines to fill height
		result := strings.Join(lines, "\n") + "\n" + content
		currentLines := strings.Count(result, "\n") + 1
		for currentLines < contentHeight {
			result += "\n"
			currentLines++
		}
		return result
	}

	titleStyle := lipgloss.NewStyle().Bold(true)
	dateStyle := lipgloss.NewStyle().Foreground(lipgloss.Color("241"))

	visibleHeight := m.getContentHeight()
	if visibleHeight < 1 {
		visibleHeight = 1
	}

	// Calculate line boundaries for each reminder
	bounds := []reminderBounds{}
	currentLine := 0

	for _, reminder := range filtered {
		start := currentLine
		currentLine++ // title line
		currentLine++ // date/countdown line

		if reminder.Notes != "" {
			noteLines := strings.Split(reminder.Notes, "\n")
			for _, line := range noteLines {
				if strings.TrimSpace(line) != "" {
					currentLine++
				}
			}
		}
		currentLine++ // blank line

		bounds = append(bounds, reminderBounds{start, currentLine})
	}

	// Compute local scroll to keep current reminder visible (do not mutate model here)
	scroll := m.scrollOffset
	if m.cursor < len(bounds) {
		cursorStart := bounds[m.cursor].startLine
		cursorEnd := bounds[m.cursor].endLine

		// Scroll up if cursor is above visible area
		if cursorStart < scroll {
			scroll = cursorStart
		}

		// Scroll down if cursor is below visible area
		if cursorEnd > scroll+visibleHeight {
			scroll = cursorEnd - visibleHeight
			if scroll < 0 {
				scroll = 0
			}
		}
	}

	// Now render with scrolling applied
	currentLine = 0
	for i, reminder := range filtered {
		cursor := "  "
		if m.cursor == i {
			cursor = "‚ñ∏ "
		}

		countdown, urgency := getCountdown(reminder.DueDate)
		urgencyColor := getUrgencyColor(urgency)
		countdownStyle := lipgloss.NewStyle().Foreground(urgencyColor)

		// Get list color
		listColor := m.listColors[reminder.List]
		listColorStyle := lipgloss.NewStyle().Foreground(lipgloss.Color(listColor))

		title := reminder.Title
		if m.cursor == i {
			title = titleStyle.Render(title)
		}

		titleLine := fmt.Sprintf("%s %s", cursor, title)
		infoLine := fmt.Sprintf("   %s ‚Ä¢ %s ‚Ä¢ %s",
			listColorStyle.Render(reminder.List),
			formatDueDate(reminder.DueDate),
			countdownStyle.Render(countdown))

		// Check if lines are in visible range
		if currentLine >= scroll && currentLine < scroll+visibleHeight {
			lines = append(lines, titleLine)
		}
		currentLine++

		if currentLine >= scroll && currentLine < scroll+visibleHeight {
			lines = append(lines, infoLine)
		}
		currentLine++

		if reminder.Notes != "" {
			noteLines := strings.Split(reminder.Notes, "\n")
			for _, line := range noteLines {
				if strings.TrimSpace(line) != "" {
					noteLine := fmt.Sprintf("   %s", dateStyle.Render(line))
					if currentLine >= scroll && currentLine < scroll+visibleHeight {
						lines = append(lines, noteLine)
					}
					currentLine++
				}
			}
		}

		if currentLine >= scroll && currentLine < scroll+visibleHeight {
			lines = append(lines, "")
		}
		currentLine++
	}

	result := strings.Join(lines, "\n")
	// Pad with empty lines to fill height
	currentLines := strings.Count(result, "\n") + 1
	for currentLines < contentHeight {
		result += "\n"
		currentLines++
	}
	return result
}

func (m model) renderColumnView() string {
	// Compute content area height (excludes footer)
	contentHeight := m.getContentHeight()

	// Build columns from reminders
	columns := getColumns(&m)
	if len(columns) == 0 {
		// Always show an empty state so the main area isn't blank
		empty := "  No reminders to display"
		lines := []string{empty}
		for len(lines) < contentHeight {
			lines = append(lines, "")
		}
		return strings.Join(lines, "\n")
	}

	// Local copy of per-column scrolls to keep rendering pure
	columnScrolls := make([]int, len(columns))
	for i := range columns {
		if i < len(m.columnScrolls) {
			columnScrolls[i] = m.columnScrolls[i]
		}
	}

	// Recompute sidebar width exactly like View() so availableWidth matches
	minMain := 20
	desiredSidebar := m.width / 3
	if desiredSidebar < 24 {
		desiredSidebar = 24
	}
	if desiredSidebar > 48 {
		desiredSidebar = 48
	}
	sidebarWidth := desiredSidebar
	if m.width-sidebarWidth < minMain {
		sidebarWidth = m.width - minMain
		if sidebarWidth < 0 {
			sidebarWidth = 0
		}
	}

	availableWidth := m.width - sidebarWidth
	if availableWidth < 1 {
		availableWidth = 1
	}

	// Work out how many columns can fit and their inner widths
	n := len(columns)
	borderAndPadding := 4 // 2 border + 2 padding
	minInner := 16
	maxInner := 48

	maxFit := availableWidth / (minInner + borderAndPadding)
	if maxFit < 1 {
		maxFit = 1
	}
	renderCount := n
	if renderCount > maxFit {
		renderCount = maxFit
	}

	innerWidth := (availableWidth - renderCount*borderAndPadding) / renderCount
	if innerWidth < minInner {
		innerWidth = minInner
	}
	if innerWidth > maxInner {
		innerWidth = maxInner
	}

	// Render each visible column with its own scroll and fixed height
	styledColumns := make([]string, 0, renderCount)
	for i := 0; i < renderCount; i++ {
		col := columns[i]
		scroll := 0
		if i < len(columnScrolls) {
			scroll = columnScrolls[i]
		}

		// Keep focused column's cursor visible (pure calculation here)
		if i == m.columnCursor && m.cursor < len(col) {
			visible := contentHeight - 2 // inside the column box (borders)
			if visible < 1 {
				visible = 1
			}
			// Roughly 4 lines per item (title, date, countdown, spacer)
			cursorLine := m.cursor * 4
			if cursorLine < scroll {
				scroll = cursorLine
			}
			if cursorLine >= scroll+visible {
				ns := cursorLine - visible + 4
				if ns < 0 {
					ns = 0
				}
				scroll = ns
			}
		}

		colStr := m.renderColumn(col, i == m.columnCursor, scroll)

		style := lipgloss.NewStyle().
			Width(innerWidth).
			Height(contentHeight).
			Padding(0, 1).
			BorderStyle(lipgloss.RoundedBorder()).
			BorderForeground(lipgloss.Color("240"))

		if i == m.columnCursor {
			style = style.BorderForeground(lipgloss.Color("205"))
		}

		styledColumns = append(styledColumns, style.Render(colStr))
	}

	// If we can't fit all columns, show a summary column at the end
	if renderCount < n {
		remaining := n - renderCount
		summary := lipgloss.NewStyle().
			Width(innerWidth).
			Height(contentHeight).
			Padding(0, 1).
			BorderStyle(lipgloss.RoundedBorder()).
			BorderForeground(lipgloss.Color("240")).
			Italic(true).
			Render(fmt.Sprintf("+ %d more‚Ä¶", remaining))
		styledColumns = append(styledColumns, summary)
	}

	return lipgloss.JoinHorizontal(lipgloss.Top, styledColumns...)
}

func (m model) renderColumn(reminders []Reminder, isFocused bool, scrollOffset int) string {
	// Always render a header so the column is never empty
	listName := "Reminders"
	if len(reminders) > 0 {
		listName = reminders[0].List
	}
	listColor := m.listColors[listName]
	headerStyle := lipgloss.NewStyle().
		Bold(true).
		Foreground(lipgloss.Color(listColor)).
		Underline(true)

	header := []string{
		headerStyle.Render(listName),
		"",
	}

	titleStyle := lipgloss.NewStyle().Bold(true)
	dateStyle := lipgloss.NewStyle().Foreground(lipgloss.Color("241"))

	// Build all item lines (without borders)
	var all []string
	if len(reminders) == 0 {
		all = append(all, "  No reminders")
	} else {
		for i, r := range reminders {
			cursor := " "
			if isFocused && m.cursor == i {
				cursor = "‚ñ∏"
			}

			countdown, urgency := getCountdown(r.DueDate)
			urgencyColor := getUrgencyColor(urgency)
			countdownStyle := lipgloss.NewStyle().Foreground(urgencyColor)

			title := r.Title
			if isFocused && m.cursor == i {
				title = titleStyle.Render(title)
			}

			all = append(all, fmt.Sprintf("%s %s", cursor, title))
			all = append(all, fmt.Sprintf("  %s", dateStyle.Render(formatDueDate(r.DueDate))))
			all = append(all, fmt.Sprintf("  %s", countdownStyle.Render(countdown)))
			if i < len(reminders)-1 {
				all = append(all, "")
			}
		}
	}

	// Calculate inner height (area inside the column borders)
	innerHeight := m.getContentHeight() - 2
	if innerHeight < 0 {
		innerHeight = 0
	}

	// The header takes two lines; use the remaining lines for items
	contentArea := innerHeight - len(header)
	if contentArea < 0 {
		contentArea = 0
	}

	// Apply vertical scrolling
	if scrollOffset < 0 {
		scrollOffset = 0
	}
	if scrollOffset > len(all) {
		scrollOffset = len(all)
	}
	end := scrollOffset + contentArea
	if end > len(all) {
		end = len(all)
	}
	visible := all[scrollOffset:end]

	// Compose and pad
	lines := append(header, visible...)
	for len(lines) < innerHeight {
		lines = append(lines, "")
	}

	return strings.Join(lines, "\n")
}